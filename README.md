# 이득우의 언리얼 c++ 게임 개발의 정석 공부



## Ch1. 개발 환경 설정

### 기본 프로그램의 설치

#### 언리얼 엔진의 설치

#### 비주얼 스튜디오 2017의 설치

언리얼 엔진은 5.1.0 버젼과 젯브레인사의 라이더 사용

### 언리얼 프로젝트의 생성

#### 기본 프로젝트의 생성

삼인칭 템플릿에 C++ 프로젝트로 시작용 콘텐츠 체크 해제 후 생성

#### 게임 프로젝트의 구동

#### C++ 프로젝트로의 확장

툴바->툴->새로운 C++ 클래스 선택 해서 C++ 클래스 생성

### 언리얼 C++ 개발 환경 설정

#### 언리얼 모듈의 빌드 설정

#### 비주얼 스튜디오의 환경 설정

### 예제 프로젝트의 준비

#### 예제 패키지의 추가

에픽 게임즈 런처->언리얼 엔진->마켓플레이스->Infinity Blade: Grass Lands 프로젝트에 추가

#### 예제 레벨의 제작

http://acornpub.co.kr/book/unreal-c#c. 예제 코드 파일 다운로드 후
Resource->Chapter1->Book 을 Content 폴더로 복사
새 레벨 생성, 에셋 배치



## Ch2. 액터의 설계

### 언리얼 콘텐츠의 구성 요소

#### 월드

#### 액터

#### 레벨

#### 컴포넌트

### 액터의 설계

스태틱 메시 컴포넌트를 가지기위해 Fountain.h에서 
액터의 멤버 변수로 2개의 스태틱 메시 컴포넌트 클래스의 포인터를 추가 선언
선언된 CoreMinimal.h(최소기능만 선언)을 EngineMinimal.h(다양한 엔진 기능 클래스 선언 모아둠) 변경

선언한 객체 자동으로 관리하게 만들기 위한 UPROPERITY 매크로 객체 지정

Fountain.cpp에서 컴포넌트를 실제로 생성하는 로직 구현. new가 아닌 CreateDefaultSubobject API라는 함수로 생성
루트 컴포넌트를 지정 후 자식 설정

### 액터와 에디터 연동

Fountain.h에서 UPROPERTY 매크로 안에 VisibleAnywhere 키워드 추가
배치된 c++ 클래스 에셋에 스태틱 메시 컴포넌트 지정

### 액터 기능의 확장

Fountain.cpp에 스태틱 메시 컴포넌트에 상대좌표위치 추가

프로젝트.build.cs에서 Niagara 모듈 추가-나이가라 컴포넌트를 사용하기 위해서
그 후 프로젝트 재구축 Generate Visual Studio project files 해준다.
나이아가라 관련 헤더파일 추가
포인트 라이트 컴포넌터, 나이가라 컴포넌트 클래스 포인터 추가
추가 컴포넌트들 생성 로직 구현, 자식 설정, 위치 설정

에디터 플로그인에서 Cascade To Niagara Converter 체크
P_Water_Fountain_Splash_Base_01 우클릭 나이아가라 시스템으로 변환했으나 컴파일 문제 발생
P_Buff_Shout_Freeze_02로 대신 사용이 에셋을 나이아가라 시스템으로 변환
변환된 시스템으로 Fountain에 Splash 에셋 지정

### 객체 유형과 값 유형

정수 유형 멤버 변수 추가



VisibleAnywhere 볼 수 있음. 편집하지 못하고 읽을 수만

EditAnywhere 편집 가능

Category=분류명 규칙 키워드

### 애셋의 지정

에디터에서 레퍼런스를 복사한 후 그 에셋을 가리키는 애셋의 포인터 변수를 선언 후
SetStaticMesh와 SetAsset 함수에 전달하여 에셋을 로딩하는 기능 완성
에셋 경로 정보 같은 경우는 게임 실행 중에 변경 될 일이 없기 때문에 static 선언

## Ch3. 움직이는 액터의 제작

### 로깅 환경의 설정

#### 출력 로그 윈도우

하단 툴바 출력 로그 창이나 창->출력 로그로 창을 뛰움
에디터 개인설정->일반->출력 로그->Output Log->Category Colorization Mode로 원하는 컬러모드 선택

로깅을 위한 공용 매크로 설정
게임 모듈명으로 된 헤더 파일과 소스 파일에 로그 매크로 선언과 정의
Fountain.h에서 포함한 EngineMinimal.h를 게임 모듈 헤더 파일로 변경
Fountain.cpp에서 로그 남김

추가로 ABLOG_S, ABLOG로 로그 매크로를 정의하고 지정하여 로그 남김

### 어설션

어설션Assertion은 반드시 확인하고 넘어가야 하는 점검 코드 의미

### 액터의 주요 이벤트 함수

EndPlay, PostInitializeComponents 함수 선언
선언한 이벤트 함수 정의 후 함수마다 로그를 남김

### 움직이는 액터의 설계

액터를 회전 시키기 위한 멤버변수 추가
데이터 은닉을 위해 private로 만들었으나 에디터에서 접근을 위해
UPROPERTY 매크로 메타키워드 AllowPrivateAccess 추가

프레임 타임 정보인 DeltaTime을 사용하여 초당 일정한 속도로 분수대를 회전시키는 코드를
틱 이벤트에 추가

### 무브먼트 컴포넌트의 활용

언리얼 엔진에서는 움직임이라는 요소를 분리해 액터와 별도로 관리하도록 프레임워크를 구성.
이것이 무브먼트 컴포넌트
무브 컴포넌트를 이용하여 움직임 구현

RotationMovementComponent 헤더파일 추가, 선언, 정의, 회전동작 추가

### 프로젝트의 재구성

분수대 액터 제거
액터 추가는 메뉴에서 가능하나 제거는 수동으로 해야한다.
소스폴더에서 관련 파일 지우고 비주얼 스튜디오 프로젝트 재생성함.



## Ch4. 게임플레이 프레임워크

### 게임 모드

게임 모드와 폰을 제작해볼 새로운 레벨 생성
게임 모드와 폰 생성 후 세팅
게임모드 생성자 코드에 DefaultPawn 속성 생성한 폰으로 지정

### 플레이어의 입장

Possess 함수 사용해서 빌드가 되지않음. OnPossess 함수 사용

4.22버전부터 OnPossess 함수 상속받도록 구조 변경됨



플레이어컨트롤러 클래스 생성
게임모드 생성자에서 플레이어컨트롤러 속성 값 생성한 클래스로 변경

생성과 빙의되는 과정을 알기 위해
게임 모드에서 플레이어 로그인 완료시 호출되는 PostLogin 선언 및 정의
플레이어 컨트롤러에서는 PostInitializeComponents, OnPossess 선언 및 정의
폰에서는 PostInitializeComponents, PossessedBy 선언 및 정의
그 함수 안에 로그 매크로 추가

에디터에서 삼인칭 캐릭터 블루프린트 배치 후 Auto Possess Player로 Player 0 설정
Player 0은 로컬 플레이어 의미. 레벨에 배치된 캐릭터 블루프린테에 빙의하게 됨.



수정할 때 모든 Possess 함수 변경하지 않아 에디터에서 플레이가 되지않는 문제 발생함.



## Ch5. 폰의 제작과 조작

### 폰의 구성 요소

마켓플레이스->InfinityBlade: Warriors 패키지를 프로젝트에 추가
폰 클래스에 캡슐컴포넌트, 스켈레탈메시컴포넌트, 플로팅폰무브먼트, 스프링암컴포넌트,
카메라컴포넌트 추가 선언
각각의 상대좌표와 회전, 해당 메시 할당등 선언한 멤버변수들 정의.

### 폰의 조작

5.10 부터는 축 및 액션 패밍은 폐기되었다고 하니 입력매핑컨텍스트와 입력액션을 활용

Book 폴더 안에 Input 폴더 생성하고 IMC_Default_AB 입력매핑컨텍스트 생성, Actions 폴더 생성 후 

폴더 안에 IA_LeftRight_AB, IA_UpDown_AB 입력 액션 생성 후 더블 클릭하여 둘다 값 타입 Axis1D(float)로 설정

상위 폴더 IMC_Default_AB를 더블클릭하고 매핑을 2개로 만들어 IA_LeftRight_AB, IA_UpDown_AB 할당

각각 액션 매핑 컨트롤 바인딩을 2개씩 추가하고 IA_LeftRight_AB는 키값을 A, D로  IA_UpDown_AB는 W와 S로 할당 S와 A는 Modifiers 배열 엘리먼트를 추가하여 인덱스 [0] Negate로 설정한다.



폰 헤더파일에 입력매핑콘텍스트 선언 추가 -  바인딩 키 설정을 입력 매핑콘텍스트에서 가져오기 위해서 이다.

앞 뒤로 이동하는 UpDown, 왼쪽 오른쪽으로 이동하는 LeftRight 함수 선언 추가 - 키를 눌렀을 때 움직임 동작을 구현하기 위한 함수이다.

생성자에서 ConstructorHelpers를 이용하여 에디터에서 입력매핑콘테스트에 레퍼런스를 복사하여 찾는다.

그리고 헤더파일에 할당한 입력매핑콘테스트를 가져온 레퍼런스로 정의한다.



비긴플레이 이벤트함수에서 플레이어컨트롤러를 가져와 향상된 입력 시스템을 이용하여 매핑콘텍스트를 추가함. 



입력신호를 자동으로 폼의 멤버 함수의 인자로 전달한다.  향상된 입력 컴포넌트를 이용하여 매핑콘텍스트에서 입력 액션들을 꺼내서 연동한다.



무브먼트를 이용하여 이동함수 구현.



플레이어 컨트롤러에게 UI를 배제하고 게임에게만 입력을 전달하도록 명령



### 애니메이션

에러 발생

비긴플레이에 잘못 씀



예제 코드의 애니메이션 파일 추가, 임포트
애니메이션 블루프린트 생성.
애님 인스턴스 속성 지정.



## Ch6. 캐릭터의 제작과 컨트롤

### 캐릭터 모델

캐릭터 클래스를 부모로 삼는 C++ 클래스 생성
폰클래스 제작할 때 처럼 스프링암, 카메라 추가
스켈레탈 메시 지정, 애님인스턴스 지정.
향상된 입력을 이용하여 키 바인딩. 
게임모드 디폴트 폰 클래스를 제작한 클래스로 변경.



### 컨트롤 회전의 활용

마우스가 바인딩이 안되는 현상 발생 왜일까?

향상된 입력을 사용하는 데 입력매핑콘텍스트만 활용하여 바인딩 하였는 데 입력 액션에

설정한 키를 키가 생성된 순서로 집어넣어 뒤죽박죽 들어가는 현상이 발생함.

입력 에셋 또한 헤더파일과 소스코드파일에서 선언과 정의, 에셋 지정을 해주어 문제를 해결함.



입력매핑컨텍스트로 입력액션을 접근하였는데 키바인딩 문제가 발생하여
각각의 입력 액션들도 추가로 선언, 정의, 에셋 지정하고 입력 액션에 바인딩하게 구현하였다.
Turn과 LookUp 동작 추가.



### 삼인칭 컨트롤 구현(GTA 방식)

스프링암을 다룰 SetControlMode 멤버함수 추가
움직임 동작 함수에 회전 값으로부터 방향 벡터 가져오는 코드 추가하여
시선 방향으로 동작하게 함.
캐릭터가 움직이는 방향으로 자동으로 회전시켜주는 캐릭터 무브먼트 컴포넌트의
OrientRotationToMovement 기능 사용하여 이동방향으로 캐릭터가 회전하게 함.

### 삼인칭 컨트롤 구현(디아블로 방식)

클래스 내부에 Enum 열거형 선언 해 SetControlMode의 인자 값을 분리해
현재 입력 모드를 보관할 멤버 변수 추가. 각 축의 입력을 조합해 보관할 벡터 유형의 변수 추가.

축 입력 이벤트가 발생할 때 새로 선언한 DirectionToMove 멤버 변수 업데이트하고
이후에 발생하는 Tick 로직에서 최종 멤버 변수 참고해 이동.
기존 GTA 방식처럼 디아블로 방식도 스프링암 속성 정의. 컨트롤러의 회전 속성, 움직임 정의.

UseControllerRotationYaw 속성 해제하고
캐릭터 무브먼트의 UseControllerDesiredRotation 속성을 체크하여 부드럽게 회전시킴.



### 컨트롤 설정의 변경

향상된 입력은 두 개의 입력컨텍스트매핑과 Chorded Action으로 다중키 구현
하나의 입력컨텍스트매핑과 2개의 입력액션 추가
SetControlMode를 바꾸는 함수 추가하고 바인딩.

플로트변수들과 회전변수를 추가하고 FMath::RInterpTo로 부드럽게 변하는 기능 추가.



## Ch7. 애니메이션 시스템의 설계

### 애니메이션 블루프린트

C++ 애님인스턴스 클래스 생성. 블루프린트에서 읽을 수 있는 변수 추가.
기존 애니메이션 블루프린트에 부모 클래스를 생성한 클래스로 변경.
상속 받은 변수를 이용하여 조건을 걸어 포즈를 하게함. 

### 폰과 데이터 연동

NativeUpdateAnimation 함수 선언.
이 함수는 애님 인스턴스 클래스 틱 마다 호출되는 함수
함수를 이용하여 폰에 접근해 폰의 속력 값 얻어와 변수에 저장
이 과정에서 TryGetPawnOwner 함수로 유효한 Pawn 오브젝트 포인터 받아와 속력 구함.

### 스테이트 머신의 제작

애님 그래프에서 기존 연결된 노드들 끊음.
새로운 스테이트 머신 추가 후 스테이트를 추가하여 연결 후.
그 스테이트에 기존 포즈 블렌딩 노드들 추가.



### 점프 기능의 구현

점프 입력 세팅 추가
캐릭터 무브먼트 컴포넌트를 이용하여 JumpZVelocity 기본값 변경.
점프 입력을 바인딩해서 동작할 함수를 기본 제공 Jump함수 이용
점프 모션 구현을 위해서 공기중에 있는 지 체크하는 부울 변수 추가.
IsFalling함수를 이용하여 현재 공중에 떠있는 체크.

스테이트머신에서 새로운 점프 스테이트 추가
기존 Ground 스테이트와 양방향 트랜지션 추가한 후 발생 조건을
기존 추가한 부울 변수로 결정한다.
새로운 스테이트에는 어떤 애니메이션도 할당이 안되어있기 때문에
점프 할 시 기본 포즈를 취한다.



### 애니메이션 리타겟

책과는 다르게 진행 애니메이션 폴더에서 우클릭->애니메이션->IK 릭->IK 릭 생성

스켈레탈 메시 선택->SK_CharM_Cardboard 스켈레탈 메시로 선택

우선 리타겟하기 위해 IK 리타기팅 체인을 추가해야함.

콘텐츠 브라우저에 IK_Mannequin을 찾아 오픈함. 

이 구성을 따라할거임

다시 아까 만든 IK 릭 에디터로 들어가 솔버 스택->새 솔버 추가->풀 바디 IK

pelvis, spine_01, spine_02, spine_03, clavicle_l, lowerarm_l, clavicle_r, lowerarm_r, thigh_l, calf_l, thigh_r, calf_r 선택 후 우클릭->선택된 본에 세팅 추가

pelvis 우클릭->리타깃 루트 설정, 또 우클릭->선택된 솔버의 루트 본 설정

root 선택 후->IK 리타기팅->새 체인 추가->체인 이름->Root->확인->새 체인 목표추가->목표 없음

spine_01, spine_02, spine_03 선택 후->IK 리타기팅->새 체인 추가->체인 이름->Spine>확인->새 체인 목표추가->목표 없음



clavicle_l 선택 후->IK 리타기팅->새 체인 추가->체인 이름->LeftClavicle>확인->새 체인 목표추가->목표 없음

clavicle_l, upperarm_l, lowerarm_l, hand_l 선택 후->IK 리타기팅->새 체인 추가->체인 이름->LeftIArm->확인->새 체인 목표추가->목표 추가->목표 할당->생긴 LeftArm_목표 이름 hand_l_Goal로 수정

index_01_l, index_02_l 선택 후->IK 리타기팅->새 체인 추가->체인 이름->LeftIndex>확인->새 체인 목표추가->목표 없음

ring_01_l, ring_02_l 선택 후->IK 리타기팅->새 체인 추가->체인 이름->LeftRing>확인->새 체인 목표추가->목표 없음

thumb_01_l, thumb_02_l 선택 후->IK 리타기팅->새 체인 추가->체인 이름->LeftThumb>확인->새 체인 목표추가->목표 없음

lowerarm_twist_01_l 선택 후->IK 리타기팅->새 체인 추가->체인 이름->LeftLowerArmTwist01>확인->새 체인 목표추가->목표 없음

upperarm_twist_01_l 선택 후->IK 리타기팅->새 체인 추가->체인 이름->LeftUpperArmTwist01>확인->새 체인 목표추가->목표 없음

오른 쪽도 똑같이 체인이름만 Right로 바꿔서 진행



neck_01, head 선택 후->IK 리타기팅->새 체인 추가->체인 이름->Head->확인->새 체인 목표추가->목표 없음



thigh_l, calf_l, foot_l, ball_l 선택 후->IK 리타기팅->새 체인 추가->체인 이름->LeftILeg->확인->새 체인 목표추가->목표 추가->목표 할당->생긴 LeftLeg_목표 이름 foot_l_Goal로 수정

calf_twist_01_l 선택 후->IK 리타기팅->새 체인 추가->체인 이름->LeftCalfTwist01>확인->새 체인 목표추가->목표 없음

thigh_twist_01_l 선택 후->IK 리타기팅->새 체인 추가->체인 이름->LeftThighTwist01>확인->새 체인 목표추가->목표 없음

오른 쪽도 똑같이 체인이름만 Right로 바꿔서 진행

전부 할당을 했으면 애니메이션 폴더에서 우클릭->애니메이션->IK 릭->IK 리타기터 생성

IK 릭을 선택하여 다음에서 애니메이션 복사->IK_Mannequin 선택

만든 IK 리타기터로 들어가 디테일->타깃->타깃 IK 릭 에셋->만든 IK 릭 선택->타깃 프리뷰 메시->SK_CharM_Cardboard 선택

똑같이 겹쳐있기에 디테일->프리뷰 세팅->타깃 메시 오프셋을 수정->X값 200정도 적당함

체인 매핑이 자동으로 됨. 타깃 체인과 소스 체인의 이름이 같게 맞춰줌(Twist는 조금 다를 수 있음)

에셋 브라우저에서 MM_Fall_Loop, MM_Jump, MM_Land를 이용할거임

MM_Fall_Loop를 클릭하면 재생이 됨. 체인매핑->글로벌 세팅 클릭->디테일->Global Settings->글로벌 리타깃 페이즈에서 IK 활성화 체크해제하면 좀 더 자연스러움->하단 에셋 브라우저-> 선택된 애니메이션 익스포트

에셋 브라우저에서 MM_Jump 를 클릭하면 재생이 됨. 체인매핑->글로벌 세팅 클릭->디테일->Global Settings->글로벌 리타깃 페이즈에서 모두 활성화 체크하면 좀 더 자연스러움->하단 에셋 브라우저-> 선택된 애니메이션 익스포트

에셋 브라우저에서 MM_Land를 클릭하면 재생이 됨. 체인매핑->글로벌 세팅 클릭->디테일->Global Settings->글로벌 리타깃 페이즈에서 IK 활성화 체크해제하면 좀 더 자연스러움->하단 에셋 브라우저-> 선택된 애니메이션 익스포트

리타겟한 애니메이션들은 애니메이션 폴더에 익스포트한다.



